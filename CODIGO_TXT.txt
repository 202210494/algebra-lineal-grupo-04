########################  MAIN ######################## 

import tkinter as tk
from controller import ProyeccionController

if __name__ == "__main__":
    root = tk.Tk()
    app = ProyeccionController(root)
    root.mainloop()
    

######################## CONTROLADOR  ######################## 

from model import ProyeccionModel
from view import ProyeccionView
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import numpy as np
import time

class ProyeccionController:
    def __init__(self, root):
        self.model = ProyeccionModel()
        self.view = ProyeccionView(root)
        self.view.calc_button.config(command=self.calcular_proyeccion)
        self.view.calc_button_rot.config(command=self.calcular_proyeccion_rotacion)

    def calcular_proyeccion(self):
        P_P = self.view.get_punto()
        PL_M = self.view.get_plano()
        if P_P is not None and PL_M is not None:
            plano, vectores, puntos = self.model.calcular_proyeccion(P_P, PL_M)
            self.animar(plano, vectores, puntos)

    def calcular_proyeccion_rotacion(self):
        P_P = self.view.get_punto()
        PL_M = self.view.get_plano()
        rotacion = self.view.get_rotaciones()
        if P_P is not None and PL_M is not None and rotacion is not None:
            plano, vectores, puntos = self.model.calcular_proyeccion(P_P, PL_M)
            self.animar(plano, vectores, puntos, rotacion)


    '''
    def rotar_punto(self, punto, rotacion):

        Rx = np.array([[1, 0, 0],
                       [0, np.cos(rotacion[0]), -np.sin(rotacion[0])],
                       [0, np.sin(rotacion[0]), np.cos(rotacion[0])]])
        
        Ry = np.array([[np.cos(rotacion[1]), 0, np.sin(rotacion[1])],
                       [0, 1, 0],
                       [-np.sin(rotacion[1]), 0, np.cos(rotacion[1])]])
        
        Rz = np.array([[np.cos(rotacion[2]), -np.sin(rotacion[2]), 0],
                       [np.sin(rotacion[2]), np.cos(rotacion[2]), 0],
                       [0, 0, 1]])
        
        R = np.dot(Rz, np.dot(Ry, Rx)) # Rotamos en x, luego en y luego en z

        return np.dot(R, punto) # Devolvemos el punto rotado en los 3 ejes
    '''
    def rotar_punto(self, punto, rotacion):
        Rx = np.array([[1, 0, 0],
                       [0, np.cos(rotacion[0]), -np.sin(rotacion[0])],
                       [0, np.sin(rotacion[0]), np.cos(rotacion[0])]])
        Ry = np.array([[np.cos(rotacion[1]), 0, np.sin(rotacion[1])],
                       [0, 1, 0],
                       [-np.sin(rotacion[1]), 0, np.cos(rotacion[1])]])
        Rz = np.array([[np.cos(rotacion[2]), -np.sin(rotacion[2]), 0],
                       [np.sin(rotacion[2]), np.cos(rotacion[2]), 0],
                       [0, 0, 1]])
        R = Rz @ Ry @ Rx
        return R @ punto

    def animar(self, plano, vectores, puntos, rotacion=None):
        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")

        # pintamos plano con meshgrid

        X, Y = np.meshgrid(np.linspace(-5, 5), np.linspace(-5, 5))
        Z = -(plano[0] * X + plano[1] * Y + plano[3]) / plano[2] # Ecuacion del plano 

        ax.plot_surface(X, Y, Z, color="yellow", alpha=0.5)

        def update_s_r(frame):
            ax.clear()
            ax.plot_surface(X, Y, Z, color="yellow", alpha=0.5)


            if frame >= .5:
                punto = puntos["P"]
                ax.scatter(punto[0], punto[1], punto[2], c='blue', s=10,
                            label="Punto a proyectar")

            if frame >= 1 + sep:
                punto = puntos["P_0"]
                ax.scatter(punto[0], punto[1], punto[2], c='blue', s=10,
                            label="Punto origen en el plano")

            if frame >= 1 + 2 * sep:
                vector = vectores["u"]
                ax.quiver(vector[0], vector[1], vector[2], vector[3], vector[4], 
                          vector[5], color="purple", arrow_length_ratio=0, 
                          label="Vector u (P-P0)")

            if frame >= 1 + 3 * sep:
                vector = vectores["n"]
                ax.quiver(vector[0], vector[1], vector[2], vector[3], vector[4], vector[5], color="orange", arrow_length_ratio=0,
                          label="vector n (normal al plano)")
                vector = vectores["-n"]
                ax.quiver(vector[0], vector[1], vector[2], vector[3], vector[4], vector[5], color="orange", arrow_length_ratio=0)

            if frame >= 1 + 4 * sep:
                vector = vectores["proy_n_u"]
                ax.quiver(vector[0], vector[1], vector[2], vector[3], vector[4], vector[5], color="green", arrow_length_ratio=0,
                          label="Proyeccion ortogonal")

            if frame >= 1 + 5 * sep:
                punto = puntos["P_"]
                ax.scatter(punto[0], punto[1], punto[2], c='red', s=10, 
                           label="Punto proyectado")
                
        def update_con_rotacion(frame):
            ax.clear()
            ax.plot_surface(X, Y, Z, color="yellow", alpha=0.5)

            if frame >= .5:
                punto = self.rotar_punto(puntos["P"], rotacion)
                ax.scatter(punto[0], punto[1], punto[2], c='blue', s=10, label="P")

            if frame >= 1 + sep:
                punto = self.rotar_punto(puntos["P_0"], rotacion)
                ax.scatter(punto[0], punto[1], punto[2], c='blue', s=10, label="P_0")

            if frame >= 2 + sep:
                vector = vectores["u"]
                origen = self.rotar_punto(vector[:3], rotacion)
                destino = self.rotar_punto(vector[:3] + vector[3:], rotacion)
                ax.quiver(origen[0], origen[1], origen[2], destino[0]-origen[0], destino[1]-origen[1], destino[2]-origen[2], color="purple", arrow_length_ratio=0)

            if frame >= 3 + sep:
                vector = vectores["n"]
                origen = self.rotar_punto(vector[:3], rotacion)
                destino = self.rotar_punto(vector[:3] + vector[3:], rotacion)
                ax.quiver(origen[0], origen[1], origen[2], destino[0]-origen[0], destino[1]-origen[1], destino[2]-origen[2], color="orange", arrow_length_ratio=0)

                vector = vectores["-n"]
                origen = self.rotar_punto(vector[:3], rotacion)
                destino = self.rotar_punto(vector[:3] + vector[3:], rotacion)
                ax.quiver(origen[0], origen[1], origen[2], destino[0]-origen[0], destino[1]-origen[1], destino[2]-origen[2], color="orange", arrow_length_ratio=0)

            if frame >= 4 + sep:
                vector = vectores["proy_n_u"]
                origen = self


        sep = 2
        ext_dur = 6
        initial_frame = 0
        if rotacion is not None:
            initial_frame += 5 * sep


        if rotacion is not None:
            ani2 = FuncAnimation(fig, update_con_rotacion, frames=range(initial_frame + 5 * sep), interval=1000)
            ani2.save("proyeccion_rotacion.gif", fps=10)
        else:
            ani = FuncAnimation(fig, update_s_r, frames=range(initial_frame + (7+ext_dur) * sep), interval=1000)
            ani.save("proyeccion.gif", fps=10)
        
        plt.show()



######################## MODELO  ######################## 

import numpy as np

class ProyeccionModel:
    def __init__(self):
        self.puntos = {}
        self.vectores = {}
    

    '''
    Logica del m para calcular la proyeccion de un punto sobre un plano
    nos devuelve el plano, los vectores y los puntos
    '''
    def calcular_proyeccion(self, P_P, PL_M):

        self.puntos["P"] = P_P # punto a proyectar
        P_P0 = np.array([0, 0, -1 * PL_M[3] / PL_M[2]]) # punto de origen del plano
        self.puntos["P_0"] = P_P0 

        # hallar vector P-P0 (u)
        vec_u = P_P0 - P_P # vector P-P0 (u)
        self.vectores["u"] = np.concatenate([P_P, vec_u])
        vec_n = PL_M[:3]

        # hallar vector normal del plano N (n), paralelo a la proyeccion
        self.vectores["n"] = np.concatenate([P_P0, vec_n / np.linalg.norm(vec_n)])
        self.vectores["-n"] = np.concatenate([P_P0, -vec_n / np.linalg.norm(vec_n)])
        
        # hallar vector P-P'(proy_n_u) [proyeccion ortogonal]
        proy_n_u = np.dot(vec_u, -vec_n) / np.linalg.norm(-vec_n) ** 2 * -vec_n
        self.vectores["proy_n_u"] = np.concatenate([P_P, proy_n_u])
        # hallar punto proyectado P'
        P_P_ = P_P + proy_n_u
        self.puntos["P_"] = P_P_

        # mandamos el plano, los vectores y los puntos
        return PL_M, self.vectores, self.puntos 


######################## VISTA  ######################## 



import tkinter as tk
from tkinter import messagebox
import numpy as np

class ProyeccionView:
    def __init__(self, root):
        self.root = root
        self.root.title("Calculadora de Proyección Ortogonal y Rotaciones")

        self.frame_punto = tk.Frame(root)
        self.frame_punto.pack(pady=10)
        tk.Label(self.frame_punto, text="Punto a proyectar (x, y, z):").grid(row=0, columnspan=6)

        tk.Label(self.frame_punto, text="x:").grid(row=1, column=0)
        self.entry_px = tk.Entry(self.frame_punto)
        self.entry_px.grid(row=1, column=1)

        tk.Label(self.frame_punto, text="y:").grid(row=1, column=2)
        self.entry_py = tk.Entry(self.frame_punto)
        self.entry_py.grid(row=1, column=3)

        tk.Label(self.frame_punto, text="z:").grid(row=1, column=4)
        self.entry_pz = tk.Entry(self.frame_punto)
        self.entry_pz.grid(row=1, column=5)

        ############################## Ecucacion del plano ##############################
        # Todo: disminuir el tamaño de los entrys (padx=5, pady=3) (ir probando con valores)
        # sino mover el columnspan=3

        self.frame_plano = tk.Frame(root)
        self.frame_plano.pack(pady=10)
        tk.Label(self.frame_plano, text="Plano (ax + by + cz + d = 0):").grid(row=0, columnspan=5)

        self.entry_a = tk.Entry(self.frame_plano)
        self.entry_a.grid(row=1, column=0, padx=5) 
        tk.Label(self.frame_plano, text="x + ").grid(row=1, column=1)
        

        
        self.entry_b = tk.Entry(self.frame_plano)
        self.entry_b.grid(row=1, column=2, padx=2)
        tk.Label(self.frame_plano, text="y + ").grid(row=1, column=3)

        self.entry_c = tk.Entry(self.frame_plano)
        self.entry_c.grid(row=1, column=4)
        tk.Label(self.frame_plano, text="z + ").grid(row=1, column=5)
        
        self.entry_d = tk.Entry(self.frame_plano)
        self.entry_d.grid(row=1, column=6, padx=7)      

        tk.Label(self.frame_plano, text="= 0").grid(row=1, column=7)

        # TODO: leer ecucacion del plano en un solo entry

        self.frame_plano2 = tk.Frame(root)
        self.frame_plano2.pack(pady=10)
        tk.Label(self.frame_plano2, text="Ecuacion del Plano:").grid(row=0, columnspan=8)
        tk.Label(self.frame_plano2, text="(ax + by + cz + d = 0):").grid(row=1, column=0)
        self.entry_plano = tk.Entry(self.frame_plano2)
        self.entry_plano.grid(row=1, column=1)
    
        self.calc_button = tk.Button(root, text="Calcular y Graficar")
        self.calc_button.pack(pady=10)

        self.frame_rotaciones = tk.Frame(root)
        self.frame_rotaciones.pack(pady=10)
        tk.Label(self.frame_rotaciones, text="Rotaciones sexadecimal o radian?:").grid(row=0, columnspan=8) # columnspan=8 para que ocupe todo el ancho
        
        tk.Label(self.frame_rotaciones, text="Rotacion en X:").grid(row=1, column=0)
        self.entry_rot_x = tk.Entry(self.frame_rotaciones)
        self.entry_rot_x.grid(row=1, column=1)

        tk.Label(self.frame_rotaciones, text="Rotacion en Y:").grid(row=1, column=2)
        self.entry_rot_y = tk.Entry(self.frame_rotaciones)
        self.entry_rot_y.grid(row=1, column=3)

        tk.Label(self.frame_rotaciones, text="Rotacion en Z:").grid(row=1, column=4)
        self.entry_rot_z = tk.Entry(self.frame_rotaciones)
        self.entry_rot_z.grid(row=1, column=5)
        
        self.calc_button_rot = tk.Button(root, text="Calcular Proyeccion con Rotaciones")
        self.calc_button_rot.pack(pady=10)



    def get_punto(self):
        try:
            P_P = np.array([float(self.entry_px.get()), float(self.entry_py.get()), float(self.entry_pz.get())])
            return P_P
        except ValueError:
            messagebox.showerror("Input Error", "Por favor, ingrese números válidos para el punto.")
            return None

    def get_plano(self):
        try:
            PL_M = np.array([float(self.entry_a.get()), float(self.entry_b.get()), float(self.entry_c.get()), float(self.entry_d.get())])
            return PL_M
        except ValueError:
            messagebox.showerror("Input Error", "Por favor, ingrese números válidos para el plano.")
            return None

    def get_rotaciones(self):
        try:
            # si no se detalla se considerara 0
            rot_x = float(self.entry_rot_x.get()) if self.entry_rot_x.get() else 0
            rot_y = float(self.entry_rot_y.get()) if self.entry_rot_y.get() else 0
            rot_z = float(self.entry_rot_z.get()) if self.entry_rot_z.get() else 0
            return np.radians([rot_x, rot_y, rot_z]) # convertir a radianes
        except ValueError:
            messagebox.showerror("Input Error", "Por favor, ingrese números válidos para las rotaciones.")
            return None